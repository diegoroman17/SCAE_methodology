ccopy_reg
_reconstructor
p1
(c__main__
LinearRegression
p2
c__builtin__
object
p3
NtRp4
(dp5
S'y_given_x'
p6
g1
(ctheano.tensor.var
TensorVariable
p7
g3
NtRp8
(dp9
S'auto_name'
p10
S'auto_16'
p11
sS'index'
p12
I0
sS'tag'
p13
(itheano.gof.utils
scratchpad
p14
(dp15
bsS'name'
p16
NsS'owner'
p17
g1
(ctheano.gof.graph
Apply
p18
g3
NtRp19
(dp20
S'inputs'
p21
(lp22
g1
(g7
g3
NtRp23
(dp24
g10
S'auto_15'
p25
sg12
I0
sg13
(itheano.gof.utils
scratchpad
p26
(dp27
S'trace'
p28
(lp29
(S'/home/diego/Dropbox/Doctorado_Diego/Implementaciones/Deep_Networks/src/linear_sgd.py'
p30
I102
S'__init__'
p31
S'self.y_given_x = T.transpose(T.dot(input, self.W) + self.b)'
tp32
asbsg16
Nsg17
g1
(g18
g3
NtRp33
(dp34
g21
(lp35
g1
(g7
g3
NtRp36
(dp37
g10
S'auto_10'
p38
sg12
I0
sg13
(itheano.gof.utils
scratchpad
p39
(dp40
g28
(lp41
(g30
I102
g31
S'self.y_given_x = T.transpose(T.dot(input, self.W) + self.b)'
tp42
asbsg16
Nsg17
g1
(g18
g3
NtRp43
(dp44
g21
(lp45
g1
(g7
g3
NtRp46
(dp47
g10
S'auto_6'
p48
sg12
Nsg13
(itheano.gof.utils
scratchpad
p49
(dp50
g28
(lp51
(S'/home/diego/Dropbox/Doctorado_Diego/Implementaciones/Deep_Networks/src/linear_sgd.py'
p52
I329
S'sgd_optimization_mnist'
p53
S"x = T.matrix('x')  # data, presented as rasterized images"
tp54
asbsg16
S'x'
sg17
NsS'type'
p55
g1
(ctheano.tensor.type
TensorType
p56
g3
NtRp57
(dp58
S'broadcastable'
p59
(I00
I00
tp60
sS'dtype'
p61
S'float64'
p62
sS'numpy_dtype'
p63
cnumpy
dtype
p64
(S'f8'
I0
I1
tRp65
(I3
S'<'
NNNI-1
I-1
I0
tbsS'sparse_grad'
p66
I00
sg16
Nsbsbag1
(ctheano.tensor.sharedvar
TensorSharedVariable
p67
g3
NtRp68
(dp69
g10
S'auto_8'
p70
sg12
Nsg13
(itheano.gof.utils
scratchpad
p71
(dp72
g28
(lp73
(S'/usr/local/lib/python2.7/dist-packages/theano/compile/sharedvalue.py'
p74
I212
S'shared'
p75
S'utils.add_tag_trace(var)'
tp76
asbsS'container'
p77
g1
(ctheano.gof.link
Container
p78
g3
NtRp79
(dp80
g16
S'W'
sS'storage'
p81
(lp82
cnumpy.core.multiarray
_reconstruct
p83
(cnumpy
ndarray
p84
(I0
tS'b'
tRp85
(I1
(I2
I1
tg65
I00
S'\xc8\xce\xff\xff\xff\xff\xef?\xa7j\xfe\xff\xff\xff\xef?'
tbasS'strict'
p86
I00
sS'readonly'
p87
I00
sg55
g1
(g56
g3
NtRp88
(dp89
g59
(I00
I00
tp90
sg61
S'float64'
p91
sg63
g65
sg66
I00
sg16
NsbsS'allow_downcast'
p92
Nsbsg16
S'W'
sg17
Nsg55
g88
sbasg13
(itheano.gof.utils
scratchpad
p93
(dp94
bsS'outputs'
p95
(lp96
g36
asS'op'
p97
g1
(ctheano.tensor.basic
Dot
p98
g3
NtRp99
(dp100
S'_op_use_c_code'
p101
S'/usr/bin/g++'
p102
sbsbsg55
g1
(g56
g3
NtRp103
(dp104
g59
(I00
I00
tp105
sg61
S'float64'
p106
sg63
g65
sg66
I00
sg16
Nsbsbag1
(g7
g3
NtRp107
(dp108
g10
S'auto_14'
p109
sg12
I0
sg13
(itheano.gof.utils
scratchpad
p110
(dp111
bsg16
Nsg17
g1
(g18
g3
NtRp112
(dp113
g21
(lp114
g1
(g67
g3
NtRp115
(dp116
g10
S'auto_9'
p117
sg12
Nsg13
(itheano.gof.utils
scratchpad
p118
(dp119
g28
(lp120
(g74
I212
g75
S'utils.add_tag_trace(var)'
tp121
asbsg77
g1
(g78
g3
NtRp122
(dp123
g16
S'b'
sg81
(lp124
g83
(g84
(I0
tS'b'
tRp125
(I1
(I1
tg65
I00
S'\xfc\xaaT\x01\xa5\xb9\x88='
tbasg86
I00
sg87
I00
sg55
g1
(g56
g3
NtRp126
(dp127
g59
(I00
tp128
sg61
S'float64'
p129
sg63
g65
sg66
I00
sg16
Nsbsg92
Nsbsg16
S'b'
sg17
Nsg55
g126
sbasg13
(itheano.gof.utils
scratchpad
p130
(dp131
bsg95
(lp132
g107
asg97
g1
(ctheano.tensor.elemwise
DimShuffle
p133
g3
NtRp134
(dp135
S'drop'
p136
(lp137
sS'shuffle'
p138
(lp139
I0
asS'augment'
p140
(lp141
I0
asS'input_broadcastable'
p142
g128
sS'inplace'
p143
I00
sS'new_order'
p144
(S'x'
I0
tp145
sg101
g102
sbsbsg55
g1
(g56
g3
NtRp146
(dp147
g59
(I01
I00
tp148
sg61
g129
sg63
g65
sg66
I00
sg16
Nsbsbasg13
(itheano.gof.utils
scratchpad
p149
(dp150
bsg95
(lp151
g23
asg97
g1
(ctheano.tensor.elemwise
Elemwise
p152
g3
NtRp153
(dp154
S'__module__'
p155
S'tensor'
p156
sS'scalar_op'
p157
g1
(ctheano.scalar.basic
Add
p158
g3
NtRp159
(dp160
S'output_types_preference'
p161
ctheano.scalar.basic
upcast_out
p162
sg101
g102
sg16
S'add'
p163
sbsg16
S'Elemwise{add,no_inplace}'
p164
sg101
g102
sS'destroy_map'
p165
(dp166
sS'nfunc_spec'
p167
(g163
I2
I1
tp168
sS'inplace_pattern'
p169
(dp170
sS'openmp'
p171
I00
sS'__doc__'
p172
S"elementwise addition\n\n    Generalizes a scalar op to tensors.\n\n    All the inputs must have the same number of dimensions. When the\n    Op is performed, for each dimension, each input's size for that\n    dimension must be the same. As a special case, it can also be 1\n    but only if the input's broadcastable flag is True for that\n    dimension. In that case, the tensor is (virtually) replicated\n    along that dimension to match the size of the others.\n\n    The dtypes of the outputs mirror those of the scalar Op that is\n    being generalized to tensors. In particular, if the calculations\n    for an output are done inplace on an input, the output type must\n    be the same as the corresponding input type (see the doc of\n    scalar.ScalarOp to get help about controlling the output type)\n\n    Examples:\n      Elemwise(add) # represents + on tensors (x + y)\n      Elemwise(add, {0 : 0}) # represents the += operation (x += y)\n      Elemwise(add, {0 : 1}) # represents += on the second argument (y += x)\n      Elemwise(mul)(rand(10, 5), rand(1, 5)) # the second input is completed\n        # along the first dimension to match the first input\n      Elemwise(true_div)(rand(10, 5), rand(10, 1)) # same but along the\n        # second dimension\n      Elemwise(int_div)(rand(1, 5), rand(10, 1)) # the output has size (10, 5)\n      Elemwise(log)(rand(3, 4, 5))\n    "
p173
sbsbsg55
g1
(g56
g3
NtRp174
(dp175
g59
(I00
I00
tp176
sg61
g62
sg63
g65
sg66
I00
sg16
Nsbsbasg13
(itheano.gof.utils
scratchpad
p177
(dp178
bsg95
(lp179
g8
asg97
g1
(g133
g3
NtRp180
(dp181
g136
(lp182
sg138
(lp183
I1
aI0
asg140
(lp184
sg142
g176
sg143
I00
sg144
(I1
I0
tp185
sg101
g102
sbsbsg55
g1
(g56
g3
NtRp186
(dp187
g59
(I00
I00
tp188
sg61
g62
sg63
g65
sg66
I00
sg16
NsbsbsS'b'
g115
sS'params'
p189
(lp190
g68
ag115
asS'W'
g68
sS'y_pred'
p191
g8
sS'input'
p192
g46
sb.